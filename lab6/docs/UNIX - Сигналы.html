<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0437)http://esyr.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/%D0%91%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5_%D1%81%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B2%D0%B0_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%8F_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2_%D0%B2_%D0%9E%D0%A1_UNIX._%D0%A1%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB%D1%8B -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		
				<meta name="keywords" content="Операционные системы/Базовые средства взаимодействия процессов в ОС UNIX. Сигналы">
		<link rel="shortcut icon" href="http://esyr.org/favicon.ico">
		<link rel="search" type="application/opensearchdescription+xml" href="http://esyr.org/w/opensearch_desc.php" title="eSyr&#39;s wiki (Русский)">
		<link title="Creative Commons" type="application/rdf+xml" href="http://esyr.org/w/index.php?title=%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B/%D0%91%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5_%D1%81%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B2%D0%B0_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%8F_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2_%D0%B2_%D0%9E%D0%A1_UNIX._%D0%A1%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB%D1%8B&amp;action=creativecommons" rel="meta">
		<title>Операционные системы/Базовые средства взаимодействия процессов в ОС UNIX. Сигналы — eSyr's wiki</title>
		<style type="text/css" media="screen, projection">/*<![CDATA[*/
			@import "/w/skins/common/shared.css?97";
			@import "/w/skins/monobook/main.css?97";
		/*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print" href="./Операционные системы_Базовые средства взаимодействия процессов в ОС UNIX. Сигналы — eSyr&#39;s wiki_files/commonPrint.css">
		<!--[if lt IE 5.5000]><style type="text/css">@import "/w/skins/monobook/IE50Fixes.css?97";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/w/skins/monobook/IE55Fixes.css?97";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/w/skins/monobook/IE60Fixes.css?97";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/w/skins/monobook/IE70Fixes.css?97";</style><![endif]-->
		<!--[if lt IE 7]><script type="text/javascript" src="/w/skins/common/IEFixes.js?97"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
		
		<script type="text/javascript">/*<![CDATA[*/
var skin = "monobook";
var stylepath = "/w/skins";
var wgArticlePath = "/wiki/$1";
var wgScriptPath = "/w";
var wgScript = "/w/index.php";
var wgServer = "http://esyr.org";
var wgCanonicalNamespace = "";
var wgCanonicalSpecialPageName = false;
var wgNamespaceNumber = 0;
var wgPageName = "Операционные_системы/Базовые_средства_взаимодействия_процессов_в_ОС_UNIX._Сигналы";
var wgTitle = "Операционные системы/Базовые средства взаимодействия процессов в ОС UNIX. Сигналы";
var wgAction = "view";
var wgRestrictionEdit = [];
var wgRestrictionMove = [];
var wgArticleId = "3591";
var wgIsArticle = true;
var wgUserName = null;
var wgUserGroups = null;
var wgUserLanguage = "ru";
var wgContentLanguage = "ru";
var wgBreakFrames = false;
var wgCurRevisionId = "7462";
/*]]>*/</script>
                
		<script type="text/javascript" src="./Операционные системы_Базовые средства взаимодействия процессов в ОС UNIX. Сигналы — eSyr&#39;s wiki_files/wikibits.js.Без названия"><!-- wikibits js --></script><link rel="stylesheet" type="text/css" href="./Операционные системы_Базовые средства взаимодействия процессов в ОС UNIX. Сигналы — eSyr&#39;s wiki_files/KHTMLFixes.css">
		<script type="text/javascript" src="./Операционные системы_Базовые средства взаимодействия процессов в ОС UNIX. Сигналы — eSyr&#39;s wiki_files/index.php"><!-- site js --></script>
		<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Common.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
@import "/w/index.php?title=MediaWiki:Monobook.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
@import "/w/index.php?title=-&action=raw&gen=css&maxage=18000";
/*]]>*/</style>
		<!-- Head Scripts -->
		<script type="text/javascript" src="./Операционные системы_Базовые средства взаимодействия процессов в ОС UNIX. Сигналы — eSyr&#39;s wiki_files/ajax.js.Без названия"></script>
		<script type="text/javascript" src="./Операционные системы_Базовые средства взаимодействия процессов в ОС UNIX. Сигналы — eSyr&#39;s wiki_files/ajaxsearch.js.Без названия"></script>
		<script type="text/javascript">hookEvent("load", sajax_onload);</script>
	</head>
<body class="mediawiki ns-0 ltr page-Операционные_системы_Базовые_средства_взаимодействия_процессов_в_ОС_UNIX_Сигналы">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
				<h1 class="firstHeading">Операционные системы/Базовые средства взаимодействия процессов в ОС UNIX. Сигналы</h1>
		<div id="bodyContent">
			<h3 id="siteSub">Материал из eSyr's wiki.</h3>
			<div id="contentSub"></div>
						<!-- start content -->
			<p>Рассмотрим взаимодействие процессов в ОС Unix с помощью <i>сигналов</i>. 
</p>
<table id="toc" class="toc" summary="Содержание"><tbody><tr><td><div id="toctitle"><h2>Содержание</h2> <span class="toctoggle"></span></div>
<ul>
<li class="toclevel-1"><a href="#.D0.A1.D0.B8.D0.B3.D0.BD.D0.B0.D0.BB.D1.8B_.D0.B2_.D0.9E.D0.A1_Unix"><span class="tocnumber">1</span> <span class="toctext">Сигналы в ОС Unix</span></a></li>
<li class="toclevel-1"><a href="#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80:_.D0.9E.D0.B1.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D0.BA.D0.B0_.D1.81.D0.B8.D0.B3.D0.BD.D0.B0.D0.BB.D0.B0"><span class="tocnumber">2</span> <span class="toctext">Пример: Обработка сигнала</span></a></li>
<li class="toclevel-1"><a href="#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80:_.D0.9F.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B0_.E2.80.9C.D0.91.D1.83.D0.B4.D0.B8.D0.BB.D1.8C.D0.BD.D0.B8.D0.BA.E2.80.9D"><span class="tocnumber">3</span> <span class="toctext">Пример: Программа “Будильник”</span></a></li>
<li class="toclevel-1"><a href="#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80:_.D0.94.D0.B2.D1.83.D1.85.D0.BF.D1.80.D0.BE.D1.86.D0.B5.D1.81.D1.81.D0.BD.D1.8B.D0.B9_.D0.B2.D0.B0.D1.80.D0.B8.D0.B0.D0.BD.D1.82_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D1.8B_.E2.80.9C.D0.91.D1.83.D0.B4.D0.B8.D0.BB.D1.8C.D0.BD.D0.B8.D0.BA.E2.80.9D"><span class="tocnumber">4</span> <span class="toctext">Пример: Двухпроцессный вариант программы “Будильник”</span></a></li>
</ul>
</td></tr></tbody></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "показать"; var tocHideText = "убрать"; showTocToggle(); } </script>
<a name=".D0.A1.D0.B8.D0.B3.D0.BD.D0.B0.D0.BB.D1.8B_.D0.B2_.D0.9E.D0.A1_Unix"></a><h2><span class="mw-headline"> Сигналы в ОС Unix </span></h2>
<p><b>Сигналы</b> представляют собой средство уведомления процесса о наступлении некоторого события в системе. 
</p><p>Инициатором посылки сигнала может выступать как другой процесс, так и сама ОС. Сигналы, посылаемые ОС, уведомляют о наступлении некоторых строго предопределенных ситуаций (как, например, завершение порожденного процесса, прерывание процесса нажатием комбинации Ctrl-C, попытка выполнить недопустимую машинную инструкцию, попытка недопустимой записи в канал и т.п.), при этом каждой такой ситуации сопоставлен свой сигнал. Кроме того, зарезервирован один или несколько номеров сигналов, семантика которых определяется пользовательскими процессами по своему усмотрению (например, процессы могут посылать друг другу сигналы с целью синхронизации).
</p><p>Количество различных сигналов в современных версиях UNIX около 30, каждый из них имеет уникальное имя и номер. Описания представлены в файле &lt;signal.h&gt;. В таблице приведено несколько примеров сигналов:
</p>
<table border="1" align="center">
<tbody><tr>
<td><b>Числовое значение</b>
</td><td><b>Константа</b>
</td><td><b>Значение сигнала</b>
</td></tr>
<tr>
<td>2
</td><td>SIGINT
</td><td>Прерывание выполнения по нажатию Ctrl-C
</td></tr>
<tr>
<td>3
</td><td>SIGQUIT
</td><td>Аварийное завершение работы
</td></tr>
<tr>
<td>9
</td><td>SIGKILL
</td><td>Уничтожение процесса
</td></tr>
<tr>
<td>14
</td><td>SIGALRM
</td><td>Прерывание от программного таймера
</td></tr>
<tr>
<td>18
</td><td>SIGCHLD
</td><td>Завершился процесс-потомок
</td></tr></tbody></table>
<p>Сигналы являются механизмом <i>асинхронного</i> взаимодействия, т.е. момент прихода сигнала процессу заранее неизвестен. Однако, процесс может предвидеть возможность получения того или иного сигнала и установить определенную <i>реакцию</i> на его приход. В этом плане сигналы можно рассматривать как <i>программный аналог аппаратных прерываний</i>.
</p><p>При получении сигнала процессом возможны три варианта реакции на полученный сигнал:
</p>
<ul><li>Процесс реагирует на сигнал стандартным образом, установленным <i>по умолчанию</i> (для большинства сигналов действие по умолчанию – это завершение процесса)
</li><li>Процесс может установить <i>специальную</i> обработку сигнала, в этом случае по приходу сигнала вызывается функция-обработчик, определенная процессом (при этом говорят, что сигнал перехватывается)
</li><li>Процесс может <i>проигнорировать</i> сигнал
</li></ul>
<p>Для каждого сигнала процесс может устанавливать свой вариант реакции, например, некоторые сигналы он может игнорировать, некоторые перехватывать, а на остальные установить реакцию по умолчанию. При этом в процессе своей работы процесс может изменять вариант реакции на тот или иной сигнал. Однако, необходимо отметить,  что некоторые сигналы невозможно ни перехватить, ни игнорировать. Они используются ядром ОС для управления работой процессов (например, SIGKILL, SIGSTOP).
</p><p>Если в процесс одновременно доставляется несколько различных сигналов, то <i>порядок их обработки не определен</i>. Если же обработки ждут несколько экземпляров одного и того же сигнала, то ответ на вопрос, сколько экземпляров будет доставлено в процесс – все или один – зависит от конкретной реализации ОС.
</p><p>Отдельного рассмотрения заслуживает ситуация, когда сигнал приходит в момент выполнения системного вызова. Обработка такой ситуации в разных версиях UNIX реализована по-разному, например, обработка сигнала может быть отложена до завершения системного вызова; либо системный вызов автоматически перезапускается после его прерывания сигналом; либо системный вызов вернет –1, а в переменной errno будет установлено значение EINTR
</p><p>Для отправки сигнала существует системный вызов kill():
</p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
int kill (pid_t pid, int sig);
</pre>
<p>Первым параметром вызова служит идентификатор процесса, которому посылается сигнал (в частности, процесс может послать сигнал самому себе). Существует также возможность одновременно послать сигнал нескольким процессам, например, если значение этого параметра есть 0, сигнал будет передан всем процессам, которые принадлежат той же группе, что и процесс, посылающий сигнал, за исключением процессов с идентификаторами 0 и 1.
</p><p>Во втором параметре передается номер посылаемого сигнала. Если этот параметр равен 0, то будет выполнена проверка корректности обращения к kill() (в частности, существование процесса с идентификатором pid), но никакой сигнал в действительности посылаться не будет.
</p><p>Если процесс-отправитель не обладает правами привилегированного пользователя, то он может отправить сигнал только тем процессам, у которых реальный или эффективный идентификатор владельца процесса совпадает с реальным или эффективным идентификатором владельца процесса-отправителя.
</p><p>Для определения реакции на получение того или иного сигнала в процессе служит системный вызов signal():
</p>
<pre>#include &lt;signal.h&gt;
void (*signal  ( int sig, void (*disp) (int))) (int);
</pre>
<p>sig — номер сигнала, для которого устанавливается реакция, disp — либо определенная пользователем функция-обработчик сигнала, либо одна из констант: SIG_DFL и SIG_IGN.  Первая из них указывает, что необходимо установить для данного сигнала обработку по умолчанию, т.е. стандартную реакцию системы, а вторая — что данный сигнал необходимо игнорировать. При успешном завершении функция возвращает указатель на предыдущий обработчик данного сигнала (он может использоваться процессом, например, для восстановления прежней реакции на сигнал). 
</p><p>Как видно из прототипа вызова signal(), определенная пользователем функция-обработчик сигнала должна принимать один целочисленный аргумент (в нем будет передан номер обрабатываемого сигнала), и не возвращать никаких значений.
</p><p>Отметим одну особенность реализации сигналов в ранних версиях UNIX: каждый раз при получении сигнала его диспозиция (т.е. действие при получении сигнала) сбрасывается на действие по умолчанию, т.о. если процесс желает многократно обрабатывать сигнал своим собственным обработчиком, он должен каждый раз при обработке сигнала заново устанавливать реакцию на него.
</p><p>В заключении отметим, что механизм сигналов является достаточно ресурсоемким, ибо отправка сигнала представляет собой системный вызов, а доставка сигнала - прерывание выполнения процесса-получателя. Вызов функции-обработчика  и возврат требует операций со стеком. Сигналы также несут весьма ограниченную информацию. 
</p><p><br>
</p>
<a name=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80:_.D0.9E.D0.B1.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D0.BA.D0.B0_.D1.81.D0.B8.D0.B3.D0.BD.D0.B0.D0.BB.D0.B0"></a><h2><span class="mw-headline"> Пример: Обработка сигнала </span></h2>
<p>В данном примере при получении сигнала SIGINT четырежды вызывается специальный обработчик, а в пятый раз происходит обработка по умолчанию.
</p>
<pre>#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
int count = 0;
void SigHndlr (int s)   /* обработчик сигнала */
{
printf("\n I got SIGINT&nbsp;%d time(s) \n", 
++ count); 
if (count == 5) signal (SIGINT, SIG_DFL); 
/* ставим обработчик сигнала по умолчанию */
else signal (SIGINT, SigHndlr); 
/* восстанавливаем обработчик сигнала */
}

int main(int argc, char **argv)
{
signal (SIGINT, SigHndlr); /* установка реакции на сигнал */
while (1); /*”тело программы” */
return 0;
}
</pre>
<a name=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80:_.D0.9F.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B0_.E2.80.9C.D0.91.D1.83.D0.B4.D0.B8.D0.BB.D1.8C.D0.BD.D0.B8.D0.BA.E2.80.9D"></a><h2><span class="mw-headline"> Пример: Программа “Будильник” </span></h2>
<p>Программа “Будильник”.  Существуют задачи, в которых необходимо прервать выполнение процесса по истечении некоторого количества времени. Средствами ОС  “заводится” будильник, который будет поторапливать ввести некоторое имя. Системный вызов alarm():
</p>
<ol><li>include &lt;unistd.h&gt;
</li></ol>
<p>unsigned int alarm(unsigned int seconds);
/*инициализирует отложенное появление сигнала SIGALRM - процесс запрашивает ядро отправить ему самому сигнал по прошествии  определенного времени */
</p>
<pre>#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;

void alrm(int s) /*обработчик сигнала SIG_ALRM */
{
printf(“\n жду имя \n”);
alarm(5); /* заводим будильник */
signal(SIGALRM, alrm); /* переустанавливаем реакцию на сигнал */
}

int main(int argc, char **argv)
{  
char s[80];   
signal(SIGALRM, alrm); 	
/* установка обработчика alrm на приход сигнала SIG_ALRM */
alarm(5); /* заводим будильник */
printf(“Введите имя \n”);
for (;;)
{
printf(“имя:”); 
if (gets(s)&nbsp;!= NULL) break; /* ожидаем ввода имени */
};
printf(“OK! \n”);
return 0;
}
</pre>
<p>В начале программы мы устанавливаем реакцию на сигнал SIGALRM - функцию alrm(), далее мы заводим будильник, запрашиваем “Введите имя” и ожидаем ввода строки символов. Если ввод строки задерживается, то будет вызвана функция alrm(), которая напомнит, что программа “ждет имя”, опять заведет будильник и поставит себя на обработку сигнала SIGALRM еще раз. И так будет до тех пор, пока не будет введена строка. Здесь имеется один нюанс: если в момент выполнения системного вызова возникает событие, связанное с сигналом, то система прерывает выполнение системного вызова и возвращает код ответа, равный «-1». 
</p>
<a name=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80:_.D0.94.D0.B2.D1.83.D1.85.D0.BF.D1.80.D0.BE.D1.86.D0.B5.D1.81.D1.81.D0.BD.D1.8B.D0.B9_.D0.B2.D0.B0.D1.80.D0.B8.D0.B0.D0.BD.D1.82_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D1.8B_.E2.80.9C.D0.91.D1.83.D0.B4.D0.B8.D0.BB.D1.8C.D0.BD.D0.B8.D0.BA.E2.80.9D"></a><h2><span class="mw-headline"> Пример: Двухпроцессный вариант программы “Будильник” </span></h2>
<pre>#include &lt;signal.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

void alr(int s)
{ 
printf(“\n Быстрее!!! \n”);
signal(SIGALRM, alr); 
/* переустановка обработчика alr на приход сигнала SIGALRM */
}

int main(int argc, char **argv)
{ 
char s[80]; 
int pid;

signal(SIGALRM, alr); 
/* установка обработчика alr на приход сигнала SIGALRM */
if  (pid = fork()) {
for (;;) 
{
sleep(5); 	/*приостанавливаем процесс на 5 секунд */
kill(pid, SIGALRM);	
/*отправляем сигнал SIGALRM процессу- сыну */
}
	}
	else {
printf(“Введите имя \n”);
for (;;) 
{
printf(“имя:”);
if (gets(s)&nbsp;!= NULL) break; /*ожидаем ввода имени*/
}
printf(“OK!\n”);
kill(getppid(), SIGKILL); 
/* убиваем зациклившегося отца */
}
return 0;
}
</pre>
<p>В данном случае программа реализуется в двух процессах. Как и в предыдущем примере, имеется функция реакции на сигнал alr(), которая выводит на экран сообщение и переустанавливает функцию реакции на сигнал опять же на себя. В основной программе мы также указываем alr() как реакцию на SIGALRM. После этого мы запускаем сыновний процесс, и отцовский процесс (бесконечный цикл) “засыпает” на 5 единиц времени, после чего сыновнему процессу будет отправлен сигнал SIGALRM. Все, что ниже цикла, будет выполняться в процессе-сыне: мы ожидаем ввода строки, если ввод осуществлен, то происходит уничтожение отца (SIGKILL).
</p>
<!-- Saved in parser cache with key wwwesyrru-mw_:pcache:idhash:3591-0!1!0!!ru!2 and timestamp 20180410211946 -->
<div class="printfooter">
Получено с <a href="http://esyr.org/wiki/Операционные_системы/Базовые_средства_взаимодействия_процессов_в_ОС_UNIX._Сигналы">http://esyr.org/wiki/Операционные_системы/Базовые_средства_взаимодействия_процессов_в_ОС_UNIX._Сигналы</a></div>
						<!-- end content -->
</body></html>